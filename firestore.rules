/**
 * @file Firestore Security Rules for SkillHub
 *
 * @core_philosophy This ruleset enforces a strict user-ownership model for user profiles and allows public read access to course listings while restricting write access to course owners (instructors). Roles are centrally managed and not directly modifiable by users.
 * @data_structure The data is organized into three top-level collections: /users/{userId}, /roles/{roleId}, and /courses/{courseId}.  User profiles are stored under their respective user IDs. Roles are globally defined. Courses are publicly readable but writable only by the instructor.
 * @key_security_decisions
 *   - User profiles are only accessible and modifiable by the owning user. Listing of users is disallowed.
 *   - Roles are read-only and can only be created and managed through backend functions (not directly via client-side writes).
 *   - Courses are publicly readable to facilitate discovery but can only be created, updated, or deleted by the instructor.
 *   - Relational integrity is enforced on `create` operations to link user profiles to their corresponding user ID and courses to their instructor ID.
 * @denormalization Courses denormalize instructorId to simplify ownership checks for write operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profile data.
     * @path /users/{userId}
     * @allow (create) - User with UID 'user123' can create their profile at /users/user123 if the document's id field matches their UID.
     * @allow (get, update, delete) - User with UID 'user123' can access and modify their profile at /users/user123.
     * @deny (create) - User with UID 'user456' cannot create a profile at /users/user123.
     * @deny (update, delete) - User with UID 'user456' cannot modify the profile at /users/user123.
     * @deny (list) - No one can list the contents of the /users collection.
     * @principle Enforces document ownership for all operations on user profiles and prevents unauthorized listing.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == userId && request.resource.data.id == userId;
      allow update: if isOwner(userId) && resource.data.id == request.resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages role definitions.  These should be managed by backend admin processes, not client-side writes.
     * @path /roles/{roleId}
     * @allow (get, list) - Any user can read role definitions.
     * @deny (create, update, delete) - No client-side writes allowed.  Roles are managed via backend.
     * @principle Restricts write access to roles to prevent unauthorized privilege escalation.
     */
    match /roles/{roleId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Manages course information.  Courses are publicly readable, but only instructors can create, update, or delete them.
     * @path /courses/{courseId}
     * @allow (get, list) - Any user can read course information.
     * @allow (create) - User with UID 'teacher123' can create a course if request.resource.data.instructorId matches their UID.
     * @allow (update, delete) - User with UID 'teacher123' can update/delete a course if they are the instructor.
     * @deny (create) - User with UID 'student456' cannot create a course.
     * @deny (update, delete) - User with UID 'student456' cannot modify courses they don't own.
     * @principle Enforces instructor-ownership for course modifications while allowing public read access.
     */
    match /courses/{courseId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.instructorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.instructorId) && resource.data.instructorId == request.resource.data.instructorId;
      allow delete: if isExistingOwner(resource.data.instructorId);
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
  }
}